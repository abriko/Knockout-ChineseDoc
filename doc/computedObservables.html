<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Knockout : 自动计算属性</title> <link href="../css/tripoli.simple.css" type="text/css" rel="stylesheet" /> 
        <link rel="stylesheet" type="text/css" href="../css/styles.css" />
        <link rel="stylesheet" type="text/css" href="../css/smallScreen.css" media="only screen and (max-device-width: 800px)" />
        <!--[if IE]><link rel="stylesheet" type="text/css" href="../css/tripoli.simple.ie.css" /><![endif]-->
        <!--[if lte IE 7]><link rel="stylesheet" type="text/css" href="../css/ie6ie7.css" /><![endif]-->
        <!--[if lte IE 6]><link rel="stylesheet" type="text/css" href="../css/ie6.css" /><![endif]-->
        <script type="text/javascript" src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="../js/release.js"></script>
		<!--[if lt IE 7]>
<script defer type="text/javascript" src="../js/ie6pngfix.js"></script>
<![endif]-->
<link type="text/css" rel="stylesheet" href="../js/syntaxhighlighter_3.0.83/styles/shThemeFadeToGrey.css"/>  

<script type="text/javascript">
if (!window.jQuery)document.write('<script type="text/javascript" src="../js/jquery-1.7.2.min.js"><' + '/script>');
    $(function() {
		$('.cn').hover(function(){
				var t = $(this);
				t.next('.en').css('top',t.offset().top + t.height() + 10).css('left',t.offset().left).css('width',t.width()).fadeIn();
			},function(){
				$(this).next('.en').fadeOut();
			});
        // Fancy fonts
        Cufon.replace('.titillium');
        Cufon.replace('.engraved', {
            textShadow: 'rgba(253, 224, 217, 0.45) 1.2px 1px'	
        });
        
        // Syntax highlighting
        $("pre > code").each(function() {
            var codeText = $(this).text();
            $(this).parent().text(codeText).addClass("brush:js");
        });
        SyntaxHighlighter.defaults['toolbar'] = false;
        SyntaxHighlighter.defaults['gutter'] = false;
        SyntaxHighlighter.all();
        
        // Highlight current top menu item
        var desiredMenuItem = '' || 'documentation';
        $(".main-menu a[rel=" + desiredMenuItem + "]").addClass("active");
        
        // Highlight current left-hand-nav menu item
        var urlFilename = location.href.match(/\/([^\/]+)$/);
        if (urlFilename) {
            $(".leftColContents li:has(a[href$='" + urlFilename[1] + "'])").addClass("active");
        }
    });
</script> 
    </head>
    <body>
        <div id="wrapper">
            <div class="vspace"></div>
            <div class="main-menu">
    <ul>
        <li><a rel="home" href="../index.html">Home</a></li>
        <li><a rel="installation" href="./installation.html">Download / Install</a></li>
        <li><a rel="tutorials" href="http://learn.knockoutjs.com/">Tutorials</a></li>
        <li><a rel="examples" href="../examples/">Live examples</a></li>
        <li><a rel="documentation" href="./introduction.html">Documentation</a></li>
        <li><a href="http://groups.google.com/group/knockoutjs">Forum</a></li>
        <li><a href="http://github.com/SteveSanderson/knockout">Source</a></li>
    </ul>
</div>        	
<div class="clear"></div>
            <div class="vspace"></div>
            <div>	
	<div class="leftCol">		
		<div class="leftColBackground">&nbsp;</div>
		<div class="leftColContents">
			<h1>入门</h1>

<ol>
    <li><a href="introduction.html">KO工作原理及带来的好处</a></li>
    <li><a href="installation.html">下载安装</a></li>
</ol>

<h1>监控属性</h1>

<ol>
    <li><a href="observables.html">创建带有监控属性的 <em>view model</em></a></li>
    <li><a href="computedObservables.html">使用<em>自动计算属性(Computed Observables)</em></a></li>
    <li><a href="observableArrays.html">使用<em>监控数组(Observable Arrays)</em></a></li>	
</ol>

<h1>使用内置绑定</h1>

<h2>控制文本和外观</h2>
<ol>
<li><a href="visible-binding.html"><code>visible</code> 绑定</a><a class="en" href="../visible-binding.html">The <code>visible</code> binding</a></li>
<li><a href="text-binding.html"><code>text</code> 绑定</a></li>
<li><a href="html-binding.html"><code>html</code> 绑定</a></li>
<li><a href="css-binding.html"><code>css</code> 绑定</a></li>
<li><a href="style-binding.html"><code>style</code> 绑定</a></li>
<li><a href="attr-binding.html"><code>attr</code> 绑定</a></li>
</ol>

<h2>绑定逻辑控制</h2>
<ol>
<li><a href="foreach-binding.html"><code>foreach</code> 绑定</a></li>
<li><a href="if-binding.html"><code>if</code> 绑定</a></li>
<li><a href="ifnot-binding.html"><code>ifnot</code> 绑定</a></li>
<li><a href="with-binding.html"><code>with</code> 绑定</a></li>
</ol>

<h2>处理表单属性</h2>
<ol>
    <li><a href="click-binding.html"><code>click</code> 绑定</a></li>
    <li><a href="event-binding.html"><code>event</code> 绑定</a></li>
    <li><a href="submit-binding.html"><code>submit</code> 绑定</a></li>
    <li><a href="enable-binding.html"><code>enable</code> 绑定</a></li>
    <li><a href="disable-binding.html"><code>disable</code> 绑定</a></li>
    <li><a href="value-binding.html"><code>value</code> 绑定</a></li>
    <li><a href="hasfocus-binding.html"><code>hasfocus</code> 绑定</a></li>
    <li><a href="checked-binding.html"><code>checked</code> 绑定</a></li>
    <li><a href="options-binding.html"><code>options</code> 绑定</a></li>
    <li><a href="selectedOptions-binding.html"><code>selectedOptions</code> 绑定</a></li>    
    <li><a href="uniqueName-binding.html"><code>uniqueName</code> 绑定</a></li>		
</ol>

<h2>解析模板</h2>
<ol>
    <li><a href="template-binding.html"><code>template</code> 绑定</a></li>
</ol>

<h2>高级应用</h2>
<ol>
    <li><a href="custom-bindings.html">自定义绑定</a></li>
    <li><a href="json-data.html">读取和保存JSON数据</a></li>
    <li><a href="extenders.html">扩展observables监控</a></li>
    <li><a href="throttle-extender.html">The <code>throttle</code> extender</a></li>
    <li><a href="unobtrusive-event-handling.html">非显式事件绑定</a></li>
    <li><a href="fn.html"><code>fn</code> 自定义函数</a></li>
</ol>

<h2>插件</h2>
<ol>
    <li><a href="plugins-mapping.html"><code>mapping</code> 插件</a></li>
</ol>

<h1>更多信息</h1>
<ol>
    <li><a href="browser-support.html">浏览支持</a></li>
    <li><a href="http://groups.google.com/group/knockoutjs">取得帮助</a></li>
    <li><a href="links.html">在线例子</a></li>
</ol>
		</div>		
	</div>
	<div class="rightCol">
		<div class="documentation sticker">
		    <div class="content">
		    	<h1>自动计算属性(Computed Observables)</h1>	
                <p class="cn">如果你已经有了<a href='observables.html'>监控属性(observable)</a> for <code>firstName</code> 和 <code>lastName</code>,你想显示全称怎么办？这就需要用到 <em>自动计算属性(computed observables)</em> 了 – 这些函数是一个或多个监控属性， 如果他们的依赖对象改变，他们会自动跟着改变。</p>
	    	  <p class="en">What if you&#8217;ve got an <a href='observables.html'>observable</a> for <code>firstName</code>, and another for <code>lastName</code>, and you want to display the full name? That&#8217;s where <em>computed observables</em> come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</p>

<p>例如，下面的view model,</p>

<pre><code>function AppViewModel() {
    this.firstName = ko.observable(&#39;Bob&#39;);
    this.lastName = ko.observable(&#39;Smith&#39;);
}</code></pre>

<p>&#8230;你可以添加一个自动计算属性来返回姓名全称：</p>

<pre><code>function AppViewModel() {
    // ... leave firstName and lastName unchanged ...

    this.fullName = ko.computed(function() {
        return this.firstName() + &quot; &quot; + this.lastName();
    }, this);
}    </code></pre>

<p>并且绑定到UI的元素上，例如：</p>

<pre><code>The name is &lt;span data-bind=&quot;text: fullName&quot;&gt;&lt;/span&gt;</code></pre>

<p class="cn">&#8230; 不管 <code>firstName</code> 还是 <code>lastName</code> 改变，全称fullName都会自动更新（不管谁改变，执行函数都会调用一次，不管改变成什么，他的值都会更新到UI或者其他自动计算属性上）。</p>
<p class="en">&#8230; and they will be updated whenever <code>firstName</code> or <code>lastName</code> changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</p>

<h3 id='managing_this'>管理 &#8216;this&#8217;</h3>

<p><em>新手可忽略此小节，你只需要安装上面例子中的代码模式写就行了，无需知道/关注这个this。</em></p>

<p class="cn">你可能疑惑 <code>ko.computed</code> 的第二个参数是做什么用的(上面的例子中我传的是 <code>this</code> ), 它是声明执行自动计算属性的 <code>this</code> 用的。  没有它，你不能引用到 <code>this.firstName()</code> 和 <code>this.lastName()</code>。 老练的JavaScript 开发人员不觉得this怎么样，但是如果你不熟悉JavaScript，那就对它就会很陌生。(C#和Java需要不需要为set一个值为设置 <code>this</code>，但是JavaScript 需要，因为默认情况下他们的函数自身不是任何对象的一部分)。</p>
<p class="en">In case you&#8217;re wondering what the second parameter to <code>ko.computed</code> is (the bit where I passed <code>this</code> in the preceding code), that defines the value of <code>this</code> when evaluating the computed observable. Without passing it in, it would not have been possible to refer to <code>this.firstName()</code> or <code>this.lastName()</code>. Experienced JavaScript coders will regard this as obvious, but if you&#8217;re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for <code>this</code>, but JavaScript does, because its functions themselves aren&#8217;t part of any object by default.)</p>

<h4 id='a_popular_convention_that_simplifies_things'>受欢迎的简化操作</h4>

<p class="cn">如果你要将viewmodel中 <code>this</code> 复制到一个不同的变量上(传统上被称为 <code>self</code>)，你可以用<code>self</code>在整个viewmode不用担心被重定义。例如:</p>
<p class="en">There&#8217;s a popular convention for avoiding the need to track <code>this</code> altogether: if your viewmodel&#8217;s constructor copies a reference to <code>this</code> into a different variable (traditionally called <code>self</code>), you can then use <code>self</code> throughout your viewmodel and don&#8217;t have to worry about it being redefined to refer to something else. For example:</p>

<pre><code>function AppViewModel() {
    var self = this;

    self.firstName = ko.observable(&#39;Bob&#39;);
    self.lastName = ko.observable(&#39;Smith&#39;);     
    self.fullName = ko.computed(function() {
        return self.firstName() + &quot; &quot; + self.lastName();
    });
}    </code></pre>

<p class="cn">因为 <code>self</code> 已经被存储在变量中，不会再函数的闭包中被更改,但是它依然可用。你可以在<a href='examples/'>live examples</a>了解到更多。</p>
<p class="en">Because <code>self</code> is captured in the function&#8217;s closure, it remains available and consistent in any nested functions, such as the <code>ko.computed</code> evaluator. This convention is even more useful when it comes to event handlers, as you&#8217;ll see in many of the <a href='examples/'>live examples</a>.</p>

<h3 id='dependency_chains_just_work'>依赖链</h3>

<p class="cn">理所当然，如果你想你可以创建一个自动计算属性的链。例如：</p>
<p class="en">Of course, you can create whole chains of computed observables if you wish. For example, you might have:</p>

<ul>
<li class="cn"><strong>监控属性</strong> <code>items</code> 表述一组列表项</li>
<li class="en">an <strong>observable</strong> called <code>items</code> representing a set of items</li>

<li class="cn"><strong>监控属性</strong> <code>selectedIndexes</code> 保存着被用户选上的列表项的索引</li>
<li class="en">another <strong>observable</strong> called <code>selectedIndexes</code> storing which item indexes have been &#8216;selected&#8217; by the user</li>

<li class="cn"><strong>自动计算属性</strong>返回的是 <code>selectedItems</code>  返回对应于选定索引的项目对象的数组</li>
<li class="en">a <strong>computed observable</strong> called <code>selectedItems</code> that returns an array of item objects corresponding to the selected indexes</li>

<li class="cn">另一个<strong>自动计算属性</strong>返回的 <code>true</code> 或 <code>false</code> 依赖于 <code>selectedItems</code> 的各个列表项是否包含一些属性（例如，是否新的或者还未保存的）。一些UI element（像按钮的启用/禁用）的状态取决于这个值）。</li>
<li class="en">another <strong>computed observable</strong> that returns <code>true</code> or <code>false</code> depending on whether any of <code>selectedItems</code> has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</li>
</ul>

<p class="cn">然后，<code>items</code> 或者 <code>selectedIndexes</code> 的改变将会影响到所有自动计算属性的链，所有绑定这些属性的UI元素都会自动更新。多么整齐与优雅！</p>
<p class="en">Then, changes to <code>items</code> or <code>selectedIndexes</code> will ripple through the chain of computed observables, which in turn updates any UI bound to them. Very tidy and elegant.</p>

<h1 id='writeable_computed_observables'>可写的自动计算属性</h1>

<p><em>新手可忽略此小节，可写自动计算属性真的是太高端了，而且大部分情况下都用不到。</em></p>

<p class="cn">正如所学到的，自动计算属性是通过计算其它的监控属性而得到的。感觉是自动计算属性正常情况下应该是<em>只读</em>的。那么，有可能让自动计算属性支持<em>可写</em>么？ 你只需要声明自己的callback函数然后利用写入的值再处理一下相应的逻辑即可。</p>
<p class="en">As you&#8217;ve learned, computed observables have a value that is computed from other observables. In that sense, computed observables are normally <em>read-only</em>. What may seem surprising, then, is that it is possible to make computed observables <em>writeable</em>. You just need to supply your own callback function that does something sensible with written values.</p>

<p class="cn">你可以像使用普通的监控属性一样使用自动计算属性 – 数据双向绑定到DOM元素上，并且通过自定义的逻辑拦截所有的读和写操作。这是非常牛逼的特性并且可以在大范围内使用。</p>
<p class="en">You can then use your writeable computed observable exactly like a regular observable - performing two-way data binding with DOM elements, with your own custom logic intercepting all reads and writes. This is a powerful feature with a wide range of possible uses.</p>

<h3 id='example_1_decomposing_user_input'>例1：分解用户的输入</h3>

<p class="cn">返回到经典的“first name + last name = full name” 例子上，你可以让事情调回来看: 让自动计算属性 <code>fullName</code> 可写，让用户直接输入姓名全称，然后输入的值将被解析并映射写入到基本的监控属性 <code>firstName</code> 和 <code>lastName</code> 上:</p>
<p class="en">Going back to the classic &#8220;first name + last name = full name&#8221; example, you can turn things back-to-front: make the <code>fullName</code> computed observable writeable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying <code>firstName</code> and <code>lastName</code> observables:</p>

<pre><code>function MyViewModel() {
    this.firstName = ko.observable(&#39;Planet&#39;);
    this.lastName = ko.observable(&#39;Earth&#39;);
    
    this.fullName = ko.computed({
        read: function () {
            return this.firstName() + &quot; &quot; + this.lastName(); 
        },
        write: function (value) {
            var lastSpacePos = value.lastIndexOf(&quot; &quot;);
            if (lastSpacePos &gt; 0) { // Ignore values with no space character
                this.firstName(value.substring(0, lastSpacePos)); // Update &quot;firstName&quot;
                this.lastName(value.substring(lastSpacePos + 1)); // Update &quot;lastName&quot;
            }
        },
        owner: this
    });
}

ko.applyBindings(new MyViewModel());</code></pre>

<p class="cn">这个例子里，写操作的callback接受<code>写入</code>的值，把值分离出来，分别写入到“firstName”和“lastName”上。 你可以像普通情况一样将这个view model绑定到DOM元素上，如下：</p>
<p class="en">In this example, the <code>write</code> callback handles incoming values by splitting the incoming text into &#8220;firstName&#8221; and &#8220;lastName&#8221; components, and writing those values back to the underlying observables. You can bind this view model to your DOM in the obvious way, as follows:</p>

<pre><code>&lt;p&gt;First name: &lt;span data-bind=&quot;text: firstName&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Last name: &lt;span data-bind=&quot;text: lastName&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Hello, &lt;input data-bind=&quot;value: fullName&quot;/&gt;!&lt;/h2&gt;</code></pre>

<p class="cn">这是一个<a href='examples/helloWorld.html'>Hello World</a>例子的反例子，姓和名都不可编辑，相反姓和名组成的姓名全称却是可编辑的。</p>
<p class="en">This is the exact opposite of the <a href='examples/helloWorld.html'>Hello World</a> example, in that here the first and last names are not editable, but the combined full name is editable.</p>

<p class="cn">上面的view model演示的是通过<em>一个简单的参数</em>来初始化自动计算属性。你可以给下面的属性传入任何JavaScript对象：</p>
<p class="en">The preceding view model code demonstrates the <em>single parameter syntax</em> for initialising computed observables. You can pass a JavaScript object with any of the following properties:</p>

<ul>
<li class="cn"><code>read</code> &#8212; 必选，一个用来执行取得自动计算属性当前值的函数。</li>
<li class="en"><code>read</code> &#8212; Required. A function that is used to evaluate the computed observable&#8217;s current value.</li>

<li class="cn"><code>write</code> &#8212; 可选，如果声明将使你的自动计算属性可写，别的代码如果这个可写功能写入新值，通过自定义逻辑将值再写入各个基础的监控属性上。</li>
<li class="en"><code>write</code> &#8212; Optional. If given, makes the computed observable writeable. This is a function that receives values that other code is trying to write to your computed observable. It&#8217;s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</li>

<li class="cn"><code>owner</code> &#8212; 可选，如果声明，它就是KO调用 <code>read</code> 或 <code>write</code> 的callback时用到的 <code>this</code> 。查看 &#8220;管理 <code>this</code>&#8221; 获取更新信息。</li>
<li class="en"><code>owner</code> &#8212; Optional. If given, defines the value of <code>this</code> whenever KO invokes your <code>read</code> or <code>write</code> callbacks. See the section &#8220;Managing <code>this</code>&#8221; earlier on this page for more information.</li>
</ul>

<h3 id='example_2_a_value_converter'>例2：Value转换器</h3>

<p class="cn">有时候你可能需要显示一些不同格式的数据，从基础的数据转化成显示格式。比如，你存储价格为float类型，但是允许用户编辑的字段需要支持货币单位和小数点。你可以用可写的自动计算属性来实现，然后解析传入的数据到基本 float类型里：</p>
<p class="en">Sometimes you might want to represent a data point on the screen in a different format from its underlying storage. For example, you might want to store a price as a raw float value, but let the user edit it with a currency symbol and fixed number of decimal places. You can use a writeable computed observable to represent the formatted price, mapping incoming values back to the underlying float value:</p>

<pre><code>function MyViewModel() {
    this.price = ko.observable(25.99);
        
    this.formattedPrice = ko.computed({
        read: function () {
            return &#39;$&#39; + this.price().toFixed(2);
        },
        write: function (value) {
            // Strip out unwanted characters, parse as float, then write the raw data back to the underlying &quot;price&quot; observable
            value = parseFloat(value.replace(/[^\.\d]/g, &quot;&quot;));
            this.price(isNaN(value) ? 0 : value); // Write to underlying storage
        },
        owner: this
    });
}

ko.applyBindings(new MyViewModel());</code></pre>

<p>然后我们绑定formattedPrice到text box上:</p>

<pre><code>&lt;p&gt;Enter bid price: &lt;input data-bind=&quot;value: formattedPrice&quot;/&gt;&lt;/p&gt;</code></pre>

<p class="cn">所以，不管用户什么时候输入新价格，输入什么格式，text box里会自动更新为带有2位小数点和货币符号的数值。这样用户可以看到你的程序有多聪明，来告诉用户只能输入2位小数，否则的话自动删除多余的位数，当然也不能输入负数，因为 <code>write</code> 的callback函数会自动删除负号。</p>
<p class="en">Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&#8217;t enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can&#8217;t enter negative values, because the <code>write</code> callback strips off any minus sign.</p>

<h3 id='example_3_filtering_and_validating_user_input'>例3：过滤并验证用户输入</h3>

<p class="cn">例1展示的是写操作过滤的功能，如果你写的值不符合条件的话将不会被写入，忽略所有不包括空格的值。</p>
<p class="en">Example 1 showed how a writeable computed observable can effectively <em>filter</em> its incoming data by choosing not to write certain values back to the underlying observables if they don&#8217;t meet some criteria. It ignored full name values that didn&#8217;t include a space.</p>

<p class="cn">再多走一步，你可以声明一个监控属性 <code>isValid</code> 来表示最后一次写入是否合法，然后根据真假值显示相应的提示信息。稍后仔细介绍，先参考如下代码：</p>
<p class="en">Taking this a step further, you could also toggle an <code>isValid</code> flag depending on whether the latest input was satisfactory, and display a message in the UI accordingly. I&#8217;ll explain in a moment an easier way of doing validation, but first consider the following view model, which demonstrates the mechanism:</p>

<pre><code>function MyViewModel() {
    this.acceptedNumericValue = ko.observable(123);
    this.lastInputWasValid = ko.observable(true);
    
    this.attemptedValue = ko.computed({
        read: this.acceptedNumericValue,
        write: function (value) {
            if (isNaN(value))
                this.lastInputWasValid(false);    
            else {
                this.lastInputWasValid(true);
                this.acceptedNumericValue(value); // Write to underlying storage
            }
        },
        owner: this
    });    
}

ko.applyBindings(new MyViewModel());</code></pre>

<p>&#8230; 按照如下格式声明绑定元素：</p>

<pre><code>&lt;p&gt;Enter a numeric value: &lt;input data-bind=&quot;value: attemptedValue&quot;/&gt;&lt;/p&gt;
&lt;div data-bind=&quot;visible: !lastInputWasValid()&quot;&gt;That&#39;s not a number!&lt;/div&gt;</code></pre>

<p class="cn">现在，<code>acceptedNumericValue</code> 将只接受数字，其它任何输入的值都会触发显示验证信息，而会更新 <code>acceptedNumericValue</code>。</p>
<p class="en">Now, <code>acceptedNumericValue</code> will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating <code>acceptedNumericValue</code>.</p>

<p class="cn"><strong>备注:</strong>上面的例子显得杀伤力太强了，更简单的方式是在<code>&lt;input&gt;</code> 上使用jQuery Validation和 <code>number</code> class。Knockout可以和jQuery Validation一起很好的使用，参考例子：<a href='examples/gridEditor.html'>grid editor</a>。当然，上面的例子依然展示了一个如何使用自定义逻辑进行过滤和验证数据，如果验证很复杂而jQuery Validation很难使用的话，你就可以用它。</p>
<p class="en"><strong>Note:</strong> For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its <code>number</code> class on the <code>&lt;input&gt;</code> element. Knockout and jQuery Validation work together nicely, as demonstrated on the <a href='examples/gridEditor.html'>grid editor</a> example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</p>

<h1 id='how_dependency_tracking_works'>依赖跟踪如何工作的</h1>

<p><em>新手没必要知道太清楚，但是高级开发人员可以需要知道为什么自动计算属性能够自动跟踪并且自动更新UI&#8230;</em></p>

<p>事实上，非常简单，甚至说可爱。跟踪的逻辑是这样的：</p>

<ol>
<li class="cn">当你声明一个自动计算属性的时候，KO会立即调用执行函数并且获取初始化值。</li>
<li class="en">Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</li>

<l class="cn"i>当你的执行函数运行的时候，KO会把所有需要依赖的依赖属性（或者监控依赖属性）都记录到一个Log列表里。</li>
<li class="en">While your evaluator function is running, KO keeps a log of any observables (or computed observables) that your evaluator reads the value of.</li>

<li class="cn">执行函数结束以后，KO会向所有Log里需要依赖到的对象进行订阅。订阅的callback函数是重新运行你的执行函数。然后回头重新执行上面的第一步操作（并且注销不再使用的订阅）。</li>
<li class="en">When your evaluator is finished, KO sets up subscriptions to each of the observables (or computed observables) that you&#8217;ve touched. The subscription callback is set to cause your evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</li>

<li class="cn">最后KO会通知上游所有订阅它的订阅者，告诉它们我已经设置了新值。</li>
<li class="en">KO notifies any subscribers about the new value of your computed observable.</li>
</ol>

<p class="cn">所有说，KO不仅仅是在第一次执行函数执行时候探测你的依赖项，每次它都会探测。举例来说，你的依赖属性可以是动态的：依赖属性A代表你是否依赖于依赖属性B或者C，这时候只有当A或者你当前的选择B或者C改变的时候执行函数才重新执行。你不需要再声明其它的依赖：运行时会自动探测到的。</p>
<p class="en">So, KO doesn&#8217;t just detect your dependencies the first time your evaluator runs - it redetects them every time. This means, for example, that your dependencies can vary dynamically: dependency A could determine whether you also depend on B or C. Then, you&#8217;ll only be re-evaluated when either A or your current choice of B or C changes. You don&#8217;t have to declare dependencies: they&#8217;re inferred at runtime from the code&#8217;s execution.</p>

<p class="cn">另外一个技巧是：一个模板输出的绑定是自动计算属性的简单实现，如果模板读取一个监控属性的值，那模板绑定就会自动变成自动计算属性依赖于那个监控属性，监控属性一旦改变，模板绑定的自动计算属性就会自动执行。嵌套的模板也是自动的：如果模板X render模板 Y，并且Y需要显示监控属性Z的值，当Z改变的时候，由于只有Y依赖它，所以只有Y这部分进行了重新绘制（render）。</p>
<p class="en">The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</p>

<h1 id='what_happened_to_dependent_observables'>依赖监控属性(Dependent Observables)怎么不见了?</h1>

<p class="cn">在 Knockout 2.0之前,自动计算属性(Computed Observables)被称为<em>依赖监控属性(Dependent Observables)</em>。2.0版本中,我们决定将<code>ko.dependentObservable</code> 重命名为 <code>ko.computed</code>。因为它的表达和类型更容易理解。但是不用担心，这个不会影响到其他代码。在运行时，<code>ko.dependentObservable</code> 是指向到 <code>ko.computed</code> &#8212; 他们俩是等价的。</p>
<p class="en">Prior to Knockout 2.0, computed observables were known as <em>dependent observables</em>. With version 2.0, we decided to rename <code>ko.dependentObservable</code> to <code>ko.computed</code> because it is easier to explain, say, and type. But don&#8217;t worry: this won&#8217;t break any existing code. At runtime, <code>ko.dependentObservable</code> refers to the same function instance as <code>ko.computed</code> &#8212; the two are equivalent.</p>    
		    </div>
		    
		    <div class="clear"></div>
		</div>
	</div>	
</div>
            <div class="clear"></div>
            <div class="main-menu">
    <ul>
        <li><a rel="home" href="../index.html">主页</a></li>
        <li><a rel="installation" href="./installation.html">下载 / 安装</a></li>
        <li><a rel="examples" href="../examples/">在线例子</a></li>
        <li><a rel="documentation" href="./introduction.html">文档</a></li>
        <li><a href="http://groups.google.com/group/knockoutjs">论坛</a></li>
        <li><a href="http://github.com/SteveSanderson/knockout">源码</a></li>
    </ul>
</div>        	
<div class="clear"></div>
        </div>
        
    <div id="page-footer">(c) knockoutjs.com</div>

    </body>
</html>