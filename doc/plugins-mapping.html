<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Knockout : Mapping插件</title> <link href="../css/tripoli.simple.css" type="text/css" rel="stylesheet" /> 
        <link rel="stylesheet" type="text/css" href="../css/styles.css" />
        <link rel="stylesheet" type="text/css" href="../css/smallScreen.css" media="only screen and (max-device-width: 800px)" />
        <!--[if IE]><link rel="stylesheet" type="text/css" href="../css/tripoli.simple.ie.css" /><![endif]-->
        <!--[if lte IE 7]><link rel="stylesheet" type="text/css" href="../css/ie6ie7.css" /><![endif]-->
        <!--[if lte IE 6]><link rel="stylesheet" type="text/css" href="../css/ie6.css" /><![endif]-->
        <script type="text/javascript" src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="../js/release.js"></script>
		<!--[if lt IE 7]>
<script defer type="text/javascript" src="../js/ie6pngfix.js"></script>
<![endif]-->
<link type="text/css" rel="stylesheet" href="../js/syntaxhighlighter_3.0.83/styles/shThemeFadeToGrey.css"/>  

<script type="text/javascript">
if (!window.jQuery)document.write('<script type="text/javascript" src="../js/jquery-1.7.2.min.js"><' + '/script>');
    $(function() {
		$('.cn').hover(function(){
				var t = $(this);
				t.next('.en').css('top',t.offset().top + t.height() + 10).css('left',t.offset().left).css('width',t.width()).fadeIn();
			},function(){
				$(this).next('.en').fadeOut();
			});
        // Fancy fonts
        Cufon.replace('.titillium');
        Cufon.replace('.engraved', {
            textShadow: 'rgba(253, 224, 217, 0.45) 1.2px 1px'	
        });
        
        // Syntax highlighting
        $("pre > code").each(function() {
            var codeText = $(this).text();
            $(this).parent().text(codeText).addClass("brush:js");
        });
        SyntaxHighlighter.defaults['toolbar'] = false;
        SyntaxHighlighter.defaults['gutter'] = false;
        SyntaxHighlighter.all();
        
        // Highlight current top menu item
        var desiredMenuItem = '' || 'documentation';
        $(".main-menu a[rel=" + desiredMenuItem + "]").addClass("active");
        
        // Highlight current left-hand-nav menu item
        var urlFilename = location.href.match(/\/([^\/]+)$/);
        if (urlFilename) {
            $(".leftColContents li:has(a[href$='" + urlFilename[1] + "'])").addClass("active");
        }
    });
</script> 
    </head>
    <body>
        <div id="wrapper">
            <div class="vspace"></div>
            <div class="main-menu">
    <ul>
        <li><a rel="home" href="../index.html">主页</a></li>
        <li><a rel="installation" href="./installation.html">下载 / 安装</a></li>
        <li><a rel="examples" href="../examples/">在线例子</a></li>
        <li><a rel="documentation" href="./introduction.html">文档</a></li>
        <li><a href="http://groups.google.com/group/knockoutjs">论坛</a></li>
        <li><a href="http://github.com/SteveSanderson/knockout">源码</a></li>
    </ul>
</div>        	
<div class="clear"></div>
            <div class="vspace"></div>
            <div>	
	<div class="leftCol">		
		<div class="leftColBackground">&nbsp;</div>
		<div class="leftColContents">
			<h1>入门</h1>

<ol>
    <li><a href="introduction.html">KO工作原理及带来的好处</a></li>
    <li><a href="installation.html">下载安装</a></li>
</ol>

<h1>监控属性</h1>

<ol>
    <li><a href="observables.html">创建带有监控属性的 <em>view model</em></a></li>
    <li><a href="computedObservables.html">使用<em>自动计算属性(Computed Observables)</em></a></li>
    <li><a href="observableArrays.html">使用<em>监控数组(Observable Arrays)</em></a></li>	
</ol>

<h1>使用内置绑定</h1>

<h2>控制文本和外观</h2>
<ol>
<li><a href="visible-binding.html"><code>visible</code> 绑定</a><a class="en" href="visible-binding.html">The <code>visible</code> binding</a></li>
<li><a href="text-binding.html"><code>text</code> 绑定</a></li>
<li><a href="html-binding.html"><code>html</code> 绑定</a></li>
<li><a href="css-binding.html"><code>css</code> 绑定</a></li>
<li><a href="style-binding.html"><code>style</code> 绑定</a></li>
<li><a href="attr-binding.html"><code>attr</code> 绑定</a></li>
</ol>

<h2>绑定逻辑控制</h2>
<ol>
<li><a href="foreach-binding.html"><code>foreach</code> 绑定</a></li>
<li><a href="if-binding.html"><code>if</code> 绑定</a></li>
<li><a href="ifnot-binding.html"><code>ifnot</code> 绑定</a></li>
<li><a href="with-binding.html"><code>with</code> 绑定</a></li>
</ol>

<h2>处理表单属性</h2>
<ol>
    <li><a href="click-binding.html"><code>click</code> 绑定</a></li>
    <li><a href="event-binding.html"><code>event</code> 绑定</a></li>
    <li><a href="submit-binding.html"><code>submit</code> 绑定</a></li>
    <li><a href="enable-binding.html"><code>enable</code> 绑定</a></li>
    <li><a href="disable-binding.html"><code>disable</code> 绑定</a></li>
    <li><a href="value-binding.html"><code>value</code> 绑定</a></li>
    <li><a href="hasfocus-binding.html"><code>hasfocus</code> 绑定</a></li>
    <li><a href="checked-binding.html"><code>checked</code> 绑定</a></li>
    <li><a href="options-binding.html"><code>options</code> 绑定</a></li>
    <li><a href="selectedOptions-binding.html"><code>selectedOptions</code> 绑定</a></li>    
    <li><a href="uniqueName-binding.html"><code>uniqueName</code> 绑定</a></li>		
</ol>

<h2>解析模板</h2>
<ol>
    <li><a href="template-binding.html"><code>template</code> 绑定</a></li>
</ol>

<h2>高级应用</h2>
<ol>
    <li><a href="custom-bindings.html">自定义绑定</a></li>
    <li><a href="json-data.html">读取和保存JSON数据</a></li>
    <li><a href="extenders.html">扩展observables监控</a></li>
    <li><a href="throttle-extender.html">The <code>throttle</code> extender</a></li>
    <li><a href="unobtrusive-event-handling.html">非显式事件绑定</a></li>
    <li><a href="fn.html"><code>fn</code> 自定义函数</a></li>
</ol>

<h2>插件</h2>
<ol>
    <li><a href="plugins-mapping.html"><code>mapping</code> 插件</a></li>
</ol>

<h1>更多信息</h1>
<ol>
    <li><a href="browser-support.html">浏览支持</a></li>
    <li><a href="http://groups.google.com/group/knockoutjs">取得帮助</a></li>
    <li><a href="links.html">在线例子</a></li>
</ol>
		</div>		
	</div>
	<div class="rightCol">
		<div class="documentation sticker">
		    <div class="content">
		    	<h1>Mapping插件</h1>	
		    	<p class="cn">Knockout设计成允许你使用任何JavaScript对象作为view model。必须view model的一些属性是 <a href='observables.html'>observables</a>，你可以使用KO绑定他们到你的UI元素上，当这些observable值改变的时候，这些UI元素就会自动更新。</p>
                <p class="en">Knockout is designed to allow you to use arbitrary JavaScript objects as view models. As long as some of your view model&#8217;s properties are <a href='observables.html'>observables</a>, you can use KO to bind to them to your UI, and the UI will be updated automatically whenever the observable properties change.</p>

<p class="cn">绝大多数程序都需要从服务器端获取数据，但是由于服务器不知道observable的概念是什么，它只支持简单的JavaScript对象（通常是序列化以后的JSON），mapping插件可以让你很方便地将简单JavaScript对象mapp到带有observable值的view model。你也可以自己写JavaScript代码将从服务器获取的数据来构建 view model，mapping插件只是一种很好的替代而已。</p>
<p class="en">Most applications need to fetch data from a backend server. Since the server doesn&#8217;t have any concept of observables, it will just supply a plain JavaScript object (usually serialized as JSON). The mapping plugin gives you a straightforward way to map that plain JavaScript object into a view model with the appropriate observables. This is an alternative to manually writing your own JavaScript code that constructs a view model based on some data you&#8217;ve fetched from the server.</p>

<h3 id='download'>Download</h3>

<ul>
<li><strong><a href='https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output'>Version 2.0</a></strong> (8.6kb min版)</li>
</ul>

<h3 id='example_manual_mapping_without_the_komapping_plugin'>例子：手工mapping</h3>

<p class="cn">显示当前服务器时间和你网站上的当前用户数。你应该使用如下的view model来代表你的这些信息：</p>
<p class="en">You want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:</p>

<pre><code>var viewModel = {
	serverTime: ko.observable(),
	numUsers: ko.observable()
}</code></pre>

<p>然后绑定view model到HTML元素上，如下：</p>

<pre><code>The time on the server is: &lt;span data-bind=&#39;text: serverTime&#39;&gt;&lt;/span&gt;
and &lt;span data-bind=&#39;text: numUsers&#39;&gt;&lt;/span&gt; user(s) are connected.</code></pre>

<p class="cn">由于view model属性是observable的，在他们变化的时候，KO会自动更新绑定的HTML元素。</p>
<p class="en">Since the view model properties are observable, KO will automatically update the HTML elements whenever those properties change.</p>

<p>接下来，从服务器获取最新的数据。或许每隔5秒你要调用一次Ajax请求（例如，使用jQuery的 <code>$.getJSON</code> 或 <code>$.ajax</code> 函授）：</p>
<p>Next, you want to fetch the latest data from the server. Every 5 seconds you might issue an Ajax request (e.g., using jQuery&#8217;s <code>$.getJSON</code> or <code>$.ajax</code> functions):</p>

<pre><code>var data = getDataUsingAjax();			// Gets the data from the server</code></pre>

<p class="cn">然后，服务器返回和下面相似的JSON数据：</p>
<p class="en">The server might return JSON data similar to the following:</p>

<pre><code>{
	serverTime: &#39;2010-01-07&#39;,
	numUsers: 3
}</code></pre>

<p class="cn">最后，用这些数据更新你的view model（不使用mapping插件），代码如下：</p>
<p class="en">Finally, to update your view model using this data (without using the mapping plugin), you would write:</p>

<pre><code>// Every time data is received from the server:
viewModel.serverTime(data.serverTime);
viewModel.numUsers(data.numUsers);</code></pre>

<p class="cn">为了使数据显示在页面上，所有的属性都要像这样写代码。如果你的数据结构很复杂的话（例如，包含子对象或者数组），那就维护起来就相当痛苦。mapping插件就是来让你让你的JavaScript简单对象（或JSON结构）转换成observable的view model的。</p>
<p class="en">You would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.</p>

<h3 id='example_using_komapping'>例子：使用ko.mapping</h3>

<p class="cn">通过mapping插件创建 <code>viewModel</code> ，直接使用 <code>ko.mapping.fromJS</code> 函数来创建：</p>
<p class="en">To create a view model via the mapping plugin, replace the creation of <code>viewModel</code> in the code above with the <code>ko.mapping.fromJS</code> function:</p>

<pre><code>var viewModel = ko.mapping.fromJS(data);</code></pre>

<p class="cn">它会自动将 <code>data</code> 里所有的属性创建成observable类型的属性。你可以通过ko.mapping.fromJS 函数定期从服务器获取数据，然后更新你的 <code>viewModel</code>：</p>
<p class="en">This automatically creates observable properties for each of the properties on <code>data</code>. Then, every time you receive new data from the server, you can update all the properties on <code>viewModel</code> in one step by calling the <code>ko.mapping.fromJS</code> function again:</p>

<pre><code>// Every time data is received from the server:
ko.mapping.fromJS(data, viewModel);</code></pre>

<h3 id='how_things_are_mapped'>如何mapping？</h3>

<ul class="cn">
<li>对象的所有属性都被转换成observable类型值，如果获取的对象的值改变了，就会更新这个observable类型的值.</li>

<li>数组也被转换成了 <a href='observableArrays.html'>observable 数组</a>，如果服务器更新改变了数组的个数，mapping插件也会添加或者删除相应的item项，也会尽量保持和原生JavaScript数组相同的order顺序。</li>
</ul>
<ul class="en">
<li>All properties of an object are converted into an observable. If an update would change the value, it will update the observable.</li>

<li>Arrays are converted into <a href='observableArrays.html'>observable arrays</a>. If an update would change the number of items, it will perform the appropriate add/remove actions. It will also try to keep the order the same as the original JavaScript array.</li>
</ul>

<h3 id='unmapping'>Unmapping</h3>

<p class="cn">如果你想让map过的对象转换成原来的JavaScript对象，使用如下方式：</p>
<p class="en">If you want to convert your mapped object back to a regular JS object, use:</p>

<pre><code>var unmapped = ko.mapping.toJS(viewModel);</code></pre>

<p class="cn">会创建一个unmapped对象，只包含你之前map过的对象属性，换句话说，你在view model上手工添加的属性或者函数都会被忽略的，唯一例外的是 <code>_destroy</code> 属性是可以unmapped回来的，因为你从 <code>ko.observableArray</code>里destroy一个item项的时候会生成这个属性。 请参考“高级用户”小节如何配置使用。</p>
<p class="en">This will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the <code>_destroy</code> property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an <code>ko.observableArray</code>. See the &#8220;Advanced Usage&#8221; section for more details on how to configure this.</p>

<h3 id='working_with_json_strings'>与JSON字符串一起使用</h3>

<p class="cn">如果你的Ajax调用返回的是JSON字符串（而不是反序列化后的JavaScript对象），你可以使用 <code>ko.mapping.fromJSON</code> 函数来创建或者更新你的view model。用 <code>ko.mapping.toJSON</code>实现unmap。</p>
<p class="en">If your Ajax call returns a JSON string (and does not deserialize it into a JavaScript object), then you can use the function <code>ko.mapping.fromJSON</code> to create and update your view model instead. To unmap, you can use <code>ko.mapping.toJSON</code>.</p>

<p class="cn">使用.from/toJSON函数处理JSON字符串和使用.from/toJS函数处理JS对象是等价的。</p>
<p class="en">Apart from the fact that they work with JSON strings instead of JS objects these functions are completely identical to their <code>*JS</code> counterparts.</p>

<h3 id='advanced_usage'>高级用法</h3>

<p class="cn">有时候，在使用 <code>ko.mapping.fromJS</code> 的时候，可能有必要去使用mapping的高级用法来定义mapping的详细过程，以后定义了，以后再调用的时候就不必再定义了。</p>
<p class="en">Sometimes it may be necessary to have more control over how the mapping is performed. This is accomplished using <em>mapping options</em>. They can be specified during the <code>ko.mapping.fromJS</code> call. In subsequent calls you don&#8217;t need to specify them again.</p>

<p class="cn">这里有一些情形，你可能需要使用这些mapping options。</p>
<p class="en">Here a few situations in which you might want to use these mapping options.</p>

<h6 id='uniquely_identifying_objects_using_keys'>用法1：使用keys来使对象unique化</h6>

<p>你有一个JavaScript对象，如下：</p>

<pre><code>var data = {
	name: &#39;Scot&#39;,
	children: [
		{ id : 1, name : &#39;Alicw&#39; }
	]
}</code></pre>

<p class="cn">使用map插件，你可以将它map到view model上（没任何问题）：</p>
<p class="en">You can map this to a view model without any problems:</p>

<pre><code>var viewModel = ko.mapping.fromJS(data);</code></pre>

<p class="cn">现在，数据被更新成如下这样：</p>
<p class="en">Now, let&#8217;s say the data is updated to be without any typos:</p>

<pre><code>var data = {
	name: &#39;Scott&#39;,
	children: [
		{ id : 1, name : &#39;Alice&#39; }
	]
}</code></pre>

<p class="cn">这里发生了两件事： <code>name</code> 从 <code>Scot</code> 变成了 <code>Scott</code> ， <code>children[0].name</code> 从 <code>Alicw</code> 变成了 <code>Alice</code>。你可以用如下代码更新 <code>viewModel</code>：</p>
<p class="en">Two things have happened here: <code>name</code> was changed from <code>Scot</code> to <code>Scott</code> and <code>children[0].name</code> was changed from <code>Alicw</code> to the typo-free <code>Alice</code>. You can update <code>viewModel</code> based on this new data:</p>

<pre><code>ko.mapping.fromJS(data, viewModel);</code></pre>

<p class="cn">于是， <code>name</code> 像我们期望的一样更新了，但是在 <code>children</code> 数组里，子项Alicw被删除而新项Alice被添加到数组里。这不是我们所期望的，我们期望的是只是把 <code>name</code> 从 <code>Alicw</code> 更新成 <code>Alice</code>，不是替换整个item项。</p>
<p class="en">And <code>name</code> would have changed as expected. However, in the <code>children</code> array, the child (Alicw) would have been completely removed and a new one (Alice) added. This is not completely what you would have expected. Instead, you would have expected that only the <code>name</code> property of the child was updated from <code>Alicw</code> to <code>Alice</code>, not that the entire child was replaced!</p>

<p class="cn">发生的原因是，默认情况下mapping plugin插件只是简单地比较数组里的两个对象是否相等。 因为JavaScript里 <code>{ id : 1, name : &#39;Alicw&#39; }</code> 和 <code>{ id : 1, name : &#39;Alice&#39; }</code> 是不相等的，所以它认为喜欢将新项替换掉老项。</p>
<p class="en">This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object <code>{ id : 1, name : &#39;Alicw&#39; }</code> does not equal <code>{ id : 1, name : &#39;Alice&#39; }</code> it thinks that the <em>entire</em> child needs to be removed and replaced by a new one.</p>

<p class="cn">解决这个问题，你需要声明一个key让mapping插件使用，用来判断一个对象是新对象还是旧对象。代码如下：</p>
<p class="en">To solve this, you can specify which <code>key</code> the mapping plugin should use to determine if an object is new or old. You would set it up like this:</p>

<pre><code>var mapping = {
	&#39;children&#39;: {
		key: function(data) {
			return ko.utils.unwrapObservable(data.id);
		}
	}
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p class="cn">这样，每次map的时候，mapping插件都会检查数组项的 <code>id</code> 属性来判断这个数组项是需要合并的还是全新replace的。</p>
<p class="en">This way, every time the mapping plugin checks an item in the <code>children</code> array, it will only look at the <code>id</code> property to determine if an object was completely replaced or merely needs updating.</p>

<h6 id='customizing_object_construction_using_create'>用法2：用create自定义对象的构造器</h6>

<p class="cn">如果你想自己控制mapping，你也可以使用 <code>create</code> 回调。使用回调可以让你自己控制mapping。</p>
<p class="en">If you want to handle a part of the mapping yourself, you can also provide a <code>create</code> callback. If this callback is present, the mapping plugin will allow you to do this part of the mapping yourself.</p>

<p>举例，你有一个像这样的JavaScript对象：</p>

<pre><code>var data = {
	name: &#39;Graham&#39;,
	children: [
		{ id : 1, name : &#39;Lisa&#39; }
	]
}</code></pre>

<p class="cn">如果你想自己map <code>children</code> 数组，你可以这样声明：</p>
<p class="en">If you want to map the <code>children</code> array yourself, you can specify that like this:</p>

<pre><code>var mapping = {
	&#39;children&#39;: {
		create: function(options) {
			return new myChildModel(options.data);
		}
	}
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p class="cn">支持 <code>create</code> 回调的 <code>options</code> 参数是一个JavaScript对象，包含如下：</p>
<p class="en">The <code>options</code> argument supplied to your <code>create</code> callback is a JavaScript object containing:</p>

<ul class="cn">
<li><code>data</code>: JavaScript对象，包含child用到的数据</li>

<li><code>parent</code>: child对象所属的父对象或者数组</li>
</ul>
<ul class="en">
<li><code>data</code>: The JavaScript object containing the data for this child</li>

<li><code>parent</code>: The parent object or array to which this child belongs</li>
</ul>

<p class="cn">当然，在内部的 <code>create</code> 回调里，你也可以再次调用 <code>ko.mapping.fromJS</code> 。一个例子就是：如果你想让初始的JavaScript对象带有额外的依赖属性 <a href='computedObservables.html'>computed observables</a>：</p>
<p class="en">Of course, inside the <code>create</code> callback you can do another call to <code>ko.mapping.fromJS</code> if you wish. A typical use-case might be if you want to augment the original JavaScript object with some additional <a href='computedObservables.html'>computed observables</a>:</p>

<pre><code>var myChildModel = function(data) {
	ko.mapping.fromJS(data, {}, this);
	
	this.nameLength = ko.computed(function() {
		return this.name().length;
	}, this);
}</code></pre>

<h6 id='customizing_object_updating_using_update'>用法3：用update自定义对象的updating</h6>

<p class="cn">你也可以使用 <code>update</code> 回调来自定义一个对象如何更新。它接受一个需要替代的对象以及和 <code>create</code> 回调一样的 <code>options</code> 参数，你应该 <code>return</code> 更新后的值。</p>
<p class="en">You can also customize how an object is updated by specifying an <code>update</code> callback. It will receive the object it is trying to update and an <code>options</code> object which is identical to the one used by the <code>create</code> callback. You should <code>return</code> the updated value.</p>

<p class="cn"><code>update</code> 回调使用的 <code>options</code> 参数是一个JavaScript对象，包含如下内容：update 回调使用的options参数是一个JavaScript对象，包含如下内容：</p>
<p class="en">The <code>options</code> argument supplied to your <code>update</code> callback is a JavaScript object containing:</p>

<ul class="cn">
<li><code>data</code>: JavaScript对象，包含child用到的数据</li>

<li><code>parent</code>: child对象所属的父对象或者数组</li>

<li><code>observable</code>: 如果属性是observable的，这将会写入到实际的observable里</li>
</ul>
<ul class="en">
<li><code>data</code>: The JavaScript object containing the data for this child</li>

<li><code>parent</code>: The parent object or array to which this child belongs</li>

<li><code>observable</code>: If the property is an observable, this will be set to the actual observable</li>
</ul>

<p class="cn">例子，在数据显示之前，在新数据后面附加额外的字符串：</p>
<p class="en">Here is an example of a configuration that will add some text to the incoming data before updating:</p>

<pre><code>var data = {
	name: &#39;Graham&#39;,
}

var mapping = {
	&#39;name&#39;: {
		update: function(options) {
			return options.data + &#39;foo!&#39;;
		}
	}
}
var viewModel = ko.mapping.fromJS(data, mapping);
alert(viewModel.name());</code></pre>

<p>alert的结果是： <code>Grahamfoo!</code>。</p>

<h6 id='ignoring_certain_properties_using_ignore'>用法4：使用ignore忽略不需要map的属性</h6>

<p class="cn">如果在map的时候，你想忽略一些属性，你可以使用ignore累声明需要忽略的属性名称集合：</p>
<p class="en">If you want the mapping plugin to ignore some properties of your JS object (i.e. to not map them), you can specify a array of propertynames to ignore:</p>

<pre><code>var mapping = {
	&#39;ignore&#39;: [&quot;propertyToIgnore&quot;, &quot;alsoIgnoreThis&quot;]
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p class="cn">你声明的忽略数组被编译到默认的 <code>ignore</code> 数组里。你可以像下面代码一样来维护它：</p>
<p class="en">The <code>ignore</code> array you specify in the mapping options is combined with the default <code>ignore</code> array. You can manipulate this default array like this:</p>

<pre><code>var oldOptions = ko.mapping.defaultOptions().ignore;
ko.mapping.defaultOptions().ignore = [&quot;alwaysIgnoreThis&quot;];</code></pre>

<h6 id='including_certain_properties_using_include'>用法5：使用include声明需要map的属性</h6>

<p class="cn">默认情况下，当map你的view model回到JS对象是时候，只map原始view model里拥有的属性（除了例外的 <code>_destroy</code> 属性），不过，你可以使用include参数来定制：</p>
<p class="en">When converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated <code>_destroy</code> property even if it was not part of your original object. However, you can choose to customize this array:</p>

<pre><code>var mapping = {
	&#39;include&#39;: [&quot;propertyToInclude&quot;, &quot;alsoIncludeThis&quot;]
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p class="cn">你声明的 <code>include</code> 数组被编译到默认的 <code>include</code> 数组里，默认只有 <code>_destroy</code>。 你可以像这样来维护：</p>
<p class="en">The <code>include</code> array you specify in the mapping options is combined with the default <code>include</code> array, which by default only contains <code>_destroy</code>. You can manipulate this default array like this:</p>

<pre><code>var oldOptions = ko.mapping.defaultOptions().include;
ko.mapping.defaultOptions().include = [&quot;alwaysIncludeThis&quot;];</code></pre>

<h6 id='copying_certain_properties_using_copy'>用法6：使用copy来复制属性</h6>

<p class="cn">默认情况下，map的时候是把所有的值都转换成observable的，默认情况下，map的时候是把所有的值都转换成observable的， <a href='#how_things_are_mapped'>前叙</a>，如果你只是想copy属性值而不是替换成observable的，你可以将属性名称添加到copy数组：</p>
<p class="en">When converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained <a href='#how_things_are_mapped'>above</a>. If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the &#8220;copy&#8221; array:</p>

<pre><code>var mapping = {
	&#39;copy&#39;: [&quot;propertyToCopy&quot;]
}
var viewModel = ko.mapping.fromJS(data, mapping);</code></pre>

<p class="cn">你声明的<code>copy</code> 数组被编译到默认的 <code>copy</code> 数组里，默认值是空。你可以像这样来维护：</p>
<p class="en">The <code>copy</code> array you specify in the mapping options is combined with the default <code>copy</code> array, which by default is empty. You can manipulate this default array like this:</p>

<pre><code>var oldOptions = ko.mapping.defaultOptions().copy;
ko.mapping.defaultOptions().copy = [&quot;alwaysCopyThis&quot;];</code></pre>

<h6 id='specifying_the_update_target'>用法7：Specifying the update target</h6>

<p class="cn">在上面的例子，如果你想再一个class内map，你可以使用第三个参数作为操作的目标，例如：</p>
<p class="en">If, like in the example above, you are performing the mapping inside of a class, you would like to have <code>this</code> as the target of your mapping operation. The third parameter to <code>ko.mapping.fromJS</code> indicates the target. For example,</p>

<pre><code>ko.mapping.fromJS(data, {}, someObject); // overwrites properties on someObject</code></pre>

<p class="cn">所以，如果你想map一个JavaScript对象到 <code>this</code> 上，你可以这样声明：</p>
<p class="en">So, if you would like to map a JavaScript object to <code>this</code>, you can pass <code>this</code> as the third argument:</p>

<pre><code>ko.mapping.fromJS(data, {}, this);</code></pre>

<h5 id='mapping_from_multiple_sources'>从多数据源map</h5>

<p>你可以通过多次使用 <code>ko.mapping.fromJS</code>  来将多个JS对象的数据源map到一起，例如：</p>
<p>You can combine multiple JS objects in one viewmodel by applying multiple <code>ko.mapping.fromJS</code> calls, e.g.:</p>

<pre><code>var viewModel = ko.mapping.fromJS(alice, aliceMappingOptions);
ko.mapping.fromJS(bob, bobMappingOptions, viewModel);</code></pre>

<p class="cn">你声明的mapping选项option在每次调用的时候都会合并。</p>
<p class="en">Mapping options that you specify in each call will be merged.</p>

<h5 id='mapped_observable_array'>Map以后的observable数组</h5>

<p class="cn">map插件map以后生产的observable数组，带有几个额外的函数来处理带有 <code>keys</code> 的 mapping:</p>
<p class="en">Observable arrays that are generated by the mapping plugin are augmented with a few functions that can make use of the <code>keys</code> mapping:</p>

<ul>
<li>mappedRemove</li>

<li>mappedRemoveAll</li>

<li>mappedDestroy</li>

<li>mappedDestroyAll</li>

<li>mappedIndexOf</li>
</ul>

<p class="cn">它们是和 <code>ko.observableArray</code> 里的函数等价的，不同是他们通过key来处理对象。例如：</p>
<p class="en">They are functionally equivalent to the regular <code>ko.observableArray</code> functions, but can do things based on the key of the object. For example, this would work:</p>

<pre><code>var obj = [
    { id : 1 },
    { id : 2 }
]

var result = ko.mapping.fromJS(obj, {
    key: function(item) {
        return ko.utils.unwrapObservable(item.id);
    }
});

result.mappedRemove({ id : 2 });</code></pre>

<p class="cn">map过的map过的 <code>ko.observableArray</code> ，除了上面的函数还支持一个 <code>mappedCreate</code> 函数：</p>
<p class="en">The mapped observable array also exposes a <code>mappedCreate</code> function:</p>

<pre><code>var newItem = result.mappedCreate({ id : 3 });</code></pre>

<p class="cn">首先会检查key（id=3）在数组里是否存在（如果存在则抛出异常），然后，如果有create和 update回调的话会调用他们，最后创建一个新对象，并将新对象添加到数组然后返回该新对象。</p>
<p class="en">It will first check if the key is already present and will throw an exception if it is. Next, it will invoke the create and update callbacks, if any, to create the new object. Finally, it will add this object to the array and return it.</p>

<h3 id='download'>Download</h3>

<ul>
<li><strong><a href='https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output'>Version 2.0</a></strong> (8.6kb min版)</li>
</ul>    
		    </div>
		    
		    <div class="clear"></div>
		</div>
	</div>	
</div>
            <div class="clear"></div>
            <div class="main-menu">
    <ul>
        <li><a rel="home" href="../index.html">主页</a></li>
        <li><a rel="installation" href="./installation.html">下载 / 安装</a></li>
        <li><a rel="examples" href="../examples/">在线例子</a></li>
        <li><a rel="documentation" href="./introduction.html">文档</a></li>
        <li><a href="http://groups.google.com/group/knockoutjs">论坛</a></li>
        <li><a href="http://github.com/SteveSanderson/knockout">源码</a></li>
    </ul>
</div>        	
<div class="clear"></div>
        </div>
        
    <div id="page-footer">(c) knockoutjs.com</div>

    </body>
</html>